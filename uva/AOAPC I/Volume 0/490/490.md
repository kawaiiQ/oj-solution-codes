# 490 - Rotating Sentences
#### 时间限制: 3.000秒

## 题意

这道题要求将一系列输入顺时针旋转90度。因此不再像以往从左向右，从上向下的显示方式，输出会是从上向下，从右向左的。

输入最多100行，每行最多100个字符，这些字符包括：换行，空格，标点符号，数字和小写或大写英文字母（不包括换行符）。

输出后最后一行应该在最左边垂直显示，第一行应该在最右边显示。

## 思路

主要就是看怎么倒腾输入的字符串了，方法应该也比较多。

有一个比较麻烦的地方在于空格的处理，如果后输入的字符串比先输入的字符串短，那么为了让旋转后的输出能够对齐，输出的时候应该在补空格，举个栗子：

输入：

| __1__ | __2__ |       |
|-------|-------|-------|
| __1__ | __2__ | __3__ |
| __1__ |       |       |

输出：

| __1__ | __1__ | __1__ |
|-------|-------|-------|
| __空格__ | __2__ | __2__ |
| __空格__ | __3__ |       |

很多方法里输出需要判断空格还有字符串长度什么的，然后要特判输出空格什么的，比较麻烦。
这里说一下个人想的一个感觉“比较简单”的思路……

输入是一行行输入的，最先输入的在最右边。所以如果后输入的字符串更长的话就不需要考虑补空格；如果后输入的字符串比目前存在的最长字符串还要长的话那么就需要补空格了。

输入的时候直接竖着存起来，遍历一遍字符串，把当前位置的字符接到对应行的字符串的后面。遍历完之后如果还没遍历到最后一行（当前最长的字符串最后一个字符对应的行），那么之后的行每一行都接一个空格。最后输出时从第一行开始倒着输出字符串即可。

那上面的例子来说，一步步地来：

* 输入“12”后，处理后的字符串从上向下为：

    ```
    "1"
    "2"
    ```

* 输入“123”后，处理后的字符串从上向下为：

    ```
    "11"
    "22"
    "3"
    ```

* 输入“1”后，处理后的字符串从上向下为：

    ```
    "111"
    "22 "
    "3 "
    ```

* 输出时每行倒着输出：

    ```
    "111"
    " 22"
    " 3"
    ```

至于怎么判断处理后多少行呢？可以维护一个最长字符串值，或者像我一样用vector每次输入判断一下动态接……

## 代码

最近比较忙……Python代码差不多，懒得写了……

### C++代码

```
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    vector<string> m;
    string line;
    
    while(getline(cin, line)) {
        // 判断处理输入后的输入会有多少行，不够就补上。
        if(m.size() < line.size()) m.resize(line.size());

        // 处理字符串，将字符串的每个字符接到对应行的字符串后面。
        vector<string>::iterator vit = m.begin(), vend = m.end();
        string::iterator sit = line.begin(), send = line.end();
        while(sit != send) {
            *vit += *sit;
            ++sit, ++vit;
        }

        // 补全空格。
        while(vit != vend) {
            *vit += ' ';
            ++vit;
        }

    }

    // 倒着输出每一行。
    for(vector<string>::iterator vit = m.begin(), vend = m.end(); vit != vend; ++vit) {
        for(string::reverse_iterator sit = vit->rbegin(), send = vit->rend(); sit != send; ++sit) {
            cout << *sit;
        }
        cout << endl;
    }

    return 0;
}
```
